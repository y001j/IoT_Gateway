package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"math"
	"math/rand"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/nats-io/nats.go"
	"github.com/rs/zerolog"
	zlog "github.com/rs/zerolog/log"
	"github.com/y001j/iot-gateway/internal/model"
	"github.com/y001j/iot-gateway/internal/rules"
)

// TestResult æµ‹è¯•ç»“æœç»“æ„
type TestResult struct {
	TestName    string        `json:"test_name"`
	Success     bool          `json:"success"`
	Duration    time.Duration `json:"duration"`
	Message     string        `json:"message"`
	Metrics     interface{}   `json:"metrics,omitempty"`
	Error       string        `json:"error,omitempty"`
}

// TestSuite æµ‹è¯•å¥—ä»¶
type TestSuite struct {
	results []TestResult
	mu      sync.Mutex
}

func (ts *TestSuite) AddResult(result TestResult) {
	ts.mu.Lock()
	defer ts.mu.Unlock()
	ts.results = append(ts.results, result)
}

func (ts *TestSuite) PrintResults() {
	ts.mu.Lock()
	defer ts.mu.Unlock()
	
	fmt.Println("\n" + strings.Repeat("=", 80))
	fmt.Println("ğŸ§ª è§„åˆ™å¼•æ“æµ‹è¯•ç»“æœæ±‡æ€»")
	fmt.Println(strings.Repeat("=", 80))
	
	successCount := 0
	totalDuration := time.Duration(0)
	
	for _, result := range ts.results {
		status := "âŒ FAIL"
		if result.Success {
			status = "âœ… PASS"
			successCount++
		}
		
		totalDuration += result.Duration
		fmt.Printf("%s [%v] %s\n", status, result.Duration, result.TestName)
		if result.Message != "" {
			fmt.Printf("   ğŸ“ %s\n", result.Message)
		}
		if result.Error != "" {
			fmt.Printf("   ğŸš¨ é”™è¯¯: %s\n", result.Error)
		}
		if result.Metrics != nil {
			fmt.Printf("   ğŸ“Š æŒ‡æ ‡: %+v\n", result.Metrics)
		}
		fmt.Println()
	}
	
	fmt.Printf("æ€»è®¡: %d/%d é€šè¿‡, æ€»è€—æ—¶: %v\n", successCount, len(ts.results), totalDuration)
	fmt.Printf("æˆåŠŸç‡: %.1f%%\n", float64(successCount)/float64(len(ts.results))*100)
	fmt.Println(strings.Repeat("=", 80))
}

// runRuleEngineTests è¿è¡Œè§„åˆ™å¼•æ“æµ‹è¯•
func runRuleEngineTests() {
	// è®¾ç½®æ—¥å¿—
	zerolog.SetGlobalLevel(zerolog.InfoLevel)
	zlog.Logger = zlog.Output(zerolog.ConsoleWriter{Out: os.Stderr, TimeFormat: time.RFC3339})
	
	testSuite := &TestSuite{}
	
	fmt.Println("ğŸš€ å¼€å§‹è§„åˆ™å¼•æ“å…¨é¢æµ‹è¯•...")
	
	// 1. è¡¨è¾¾å¼å¼•æ“æµ‹è¯•
	testExpressionEngine(testSuite)
	
	// 2. å¢é‡ç»Ÿè®¡æµ‹è¯•
	testIncrementalStats(testSuite)
	
	// 3. èšåˆç®¡ç†å™¨æµ‹è¯•
	testAggregateManager(testSuite)
	
	// 4. è§„åˆ™æ‰§è¡Œæµ‹è¯•
	testRuleExecution(testSuite)
	
	// 5. ç›‘æ§ç³»ç»Ÿæµ‹è¯•
	testMonitoringSystem(testSuite)
	
	// 6. æ€§èƒ½åŸºå‡†æµ‹è¯•
	testPerformanceBenchmark(testSuite)
	
	// 7. å¹¶å‘å‹åŠ›æµ‹è¯•
	testConcurrencyStress(testSuite)
	
	// æ‰“å°ç»“æœ
	testSuite.PrintResults()
}

// testExpressionEngine æµ‹è¯•è¡¨è¾¾å¼å¼•æ“
func testExpressionEngine(ts *TestSuite) {
	fmt.Println("ğŸ”§ æµ‹è¯•è¡¨è¾¾å¼å¼•æ“...")
	
	start := time.Now()
	
	// åˆ›å»ºè¡¨è¾¾å¼å¼•æ“
	engine := rules.NewExpressionEngine()
	
	testCases := []struct {
		name       string
		expression string
		data       map[string]interface{}
		expected   bool
		shouldFail bool
	}{
		{
			name:       "ç®€å•æ•°å€¼æ¯”è¾ƒ",
			expression: "value > 30",
			data:       map[string]interface{}{"value": 35.5},
			expected:   true,
		},
		{
			name:       "é€»è¾‘è¿ç®—",
			expression: "value > 20 && value < 40",
			data:       map[string]interface{}{"value": 25.0},
			expected:   true,
		},
		{
			name:       "å­—ç¬¦ä¸²å‡½æ•°",
			expression: "contains(device_id, 'sensor')",
			data:       map[string]interface{}{"device_id": "sensor_001"},
			expected:   true,
		},
		{
			name:       "æ•°å­¦å‡½æ•°",
			expression: "sqrt(value) > 5",
			data:       map[string]interface{}{"value": 36.0},
			expected:   true,
		},
		{
			name:       "æ­£åˆ™è¡¨è¾¾å¼",
			expression: "regex('temp_.*', key)",
			data:       map[string]interface{}{"key": "temp_sensor_1"},
			expected:   true,
		},
		{
			name:       "æ—¶é—´èŒƒå›´",
			expression: "time_range(9, 17)",
			data:       map[string]interface{}{},
			expected:   false, // å¯èƒ½å¤±è´¥ï¼Œå–å†³äºè¿è¡Œæ—¶é—´
		},
		{
			name:       "å¤æ‚è¡¨è¾¾å¼",
			expression: "abs(value - 25) < 5 && len(device_id) > 5",
			data:       map[string]interface{}{"value": 27.0, "device_id": "sensor_001"},
			expected:   true,
		},
		{
			name:       "é”™è¯¯è¡¨è¾¾å¼",
			expression: "invalid_function(value)",
			data:       map[string]interface{}{"value": 25.0},
			shouldFail: true,
		},
	}
	
	successCount := 0
	for _, tc := range testCases {
		result, err := engine.Evaluate(tc.expression, tc.data)
		
		if tc.shouldFail {
			if err != nil {
				successCount++
				zlog.Info().Str("test", tc.name).Msg("é¢„æœŸé”™è¯¯æµ‹è¯•é€šè¿‡")
			} else {
				zlog.Error().Str("test", tc.name).Msg("é¢„æœŸé”™è¯¯ä½†æˆåŠŸæ‰§è¡Œ")
			}
		} else {
			if err != nil {
				zlog.Error().Err(err).Str("test", tc.name).Msg("è¡¨è¾¾å¼è¯„ä¼°å¤±è´¥")
			} else if result == tc.expected {
				successCount++
				zlog.Info().Str("test", tc.name).Interface("result", result).Msg("æµ‹è¯•é€šè¿‡")
			} else {
				zlog.Error().Str("test", tc.name).
					Interface("expected", tc.expected).
					Interface("actual", result).
					Msg("ç»“æœä¸åŒ¹é…")
			}
		}
	}
	
	duration := time.Since(start)
	success := successCount == len(testCases)
	
	ts.AddResult(TestResult{
		TestName: "è¡¨è¾¾å¼å¼•æ“åŠŸèƒ½æµ‹è¯•",
		Success:  success,
		Duration: duration,
		Message:  fmt.Sprintf("é€šè¿‡ %d/%d æµ‹è¯•ç”¨ä¾‹", successCount, len(testCases)),
		Metrics: map[string]interface{}{
			"test_cases":    len(testCases),
			"success_count": successCount,
			"avg_time_per_test": duration / time.Duration(len(testCases)),
		},
	})
}

// testIncrementalStats æµ‹è¯•å¢é‡ç»Ÿè®¡
func testIncrementalStats(ts *TestSuite) {
	fmt.Println("ğŸ“Š æµ‹è¯•å¢é‡ç»Ÿè®¡...")
	
	start := time.Now()
	
	// åˆ›å»ºå¢é‡ç»Ÿè®¡å®ä¾‹
	stats := rules.NewIncrementalStats(false) // ç´¯ç§¯æ¨¡å¼
	
	// æ·»åŠ æµ‹è¯•æ•°æ®
	testData := []float64{10, 20, 30, 40, 50, 25, 35, 45, 15, 55}
	
	for _, value := range testData {
		stats.AddValue(value)
	}
	
	// éªŒè¯ç»Ÿè®¡ç»“æœ
	results := stats.GetResults()
	
	// è®¡ç®—é¢„æœŸå€¼
	expectedMean := 32.5  // (10+20+30+40+50+25+35+45+15+55) / 10
	expectedSum := 325.0
	expectedCount := 10
	
	success := true
	var errors []string
	
	if math.Abs(results["avg"].(float64) - expectedMean) > 0.001 {
		success = false
		errors = append(errors, fmt.Sprintf("å¹³å‡å€¼é”™è¯¯: æœŸæœ›%.3f, å®é™…%.3f", expectedMean, results["avg"]))
	}
	
	if math.Abs(results["sum"].(float64) - expectedSum) > 0.001 {
		success = false
		errors = append(errors, fmt.Sprintf("æ±‚å’Œé”™è¯¯: æœŸæœ›%.3f, å®é™…%.3f", expectedSum, results["sum"]))
	}
	
	if results["count"].(int) != expectedCount {
		success = false
		errors = append(errors, fmt.Sprintf("è®¡æ•°é”™è¯¯: æœŸæœ›%d, å®é™…%d", expectedCount, results["count"]))
	}
	
	// æµ‹è¯•æ»‘åŠ¨çª—å£æ¨¡å¼
	windowStats := rules.NewIncrementalStats(true) // æ»‘åŠ¨çª—å£æ¨¡å¼
	windowStats.SetWindowSize(5)
	
	for _, value := range testData {
		windowStats.AddValue(value)
	}
	
	windowResults := windowStats.GetResults()
	// æœ€å5ä¸ªå€¼: 25, 35, 45, 15, 55ï¼Œå¹³å‡å€¼åº”è¯¥æ˜¯35
	expectedWindowMean := 35.0
	
	if math.Abs(windowResults["avg"].(float64) - expectedWindowMean) > 0.001 {
		success = false
		errors = append(errors, fmt.Sprintf("æ»‘åŠ¨çª—å£å¹³å‡å€¼é”™è¯¯: æœŸæœ›%.3f, å®é™…%.3f", expectedWindowMean, windowResults["avg"]))
	}
	
	duration := time.Since(start)
	errorMsg := ""
	if len(errors) > 0 {
		errorMsg = fmt.Sprintf("éªŒè¯å¤±è´¥: %v", errors)
	}
	
	ts.AddResult(TestResult{
		TestName: "å¢é‡ç»Ÿè®¡ç®—æ³•æµ‹è¯•",
		Success:  success,
		Duration: duration,
		Message:  "éªŒè¯ç´¯ç§¯æ¨¡å¼å’Œæ»‘åŠ¨çª—å£æ¨¡å¼çš„ç»Ÿè®¡è®¡ç®—",
		Error:    errorMsg,
		Metrics: map[string]interface{}{
			"cumulative_results": results,
			"window_results":     windowResults,
			"data_points":        len(testData),
		},
	})
}

// testAggregateManager æµ‹è¯•èšåˆç®¡ç†å™¨
func testAggregateManager(ts *TestSuite) {
	fmt.Println("ğŸ”„ æµ‹è¯•èšåˆç®¡ç†å™¨...")
	
	start := time.Now()
	
	// åˆ›å»ºèšåˆç®¡ç†å™¨
	manager := rules.NewAggregateManager()
	defer manager.Close()
	
	// åˆ›å»ºæµ‹è¯•è§„åˆ™
	rule := &rules.Rule{
		ID:   "test_aggregate_rule",
		Name: "æµ‹è¯•èšåˆè§„åˆ™",
	}
	
	// åˆ›å»ºèšåˆé…ç½®
	config := &rules.AggregateConfig{
		WindowSize: 5,
		Functions:  []string{"avg", "max", "min", "sum", "count"},
		GroupBy:    []string{"device_id"},
		TTL:        time.Minute * 5,
	}
	
	// åˆ›å»ºæµ‹è¯•æ•°æ®ç‚¹
	testPoints := []model.Point{
		{DeviceID: "device_001", Key: "temperature", Value: 25.0, Timestamp: time.Now()},
		{DeviceID: "device_001", Key: "temperature", Value: 30.0, Timestamp: time.Now()},
		{DeviceID: "device_001", Key: "temperature", Value: 35.0, Timestamp: time.Now()},
		{DeviceID: "device_001", Key: "temperature", Value: 20.0, Timestamp: time.Now()},
		{DeviceID: "device_001", Key: "temperature", Value: 40.0, Timestamp: time.Now()},
		{DeviceID: "device_002", Key: "temperature", Value: 50.0, Timestamp: time.Now()},
		{DeviceID: "device_002", Key: "temperature", Value: 55.0, Timestamp: time.Now()},
	}
	
	successCount := 0
	totalProcessed := 0
	
	for _, point := range testPoints {
		result, err := manager.ProcessPoint(rule, point, config)
		totalProcessed++
		
		if err != nil {
			zlog.Error().Err(err).Str("device", point.DeviceID).Msg("å¤„ç†æ•°æ®ç‚¹å¤±è´¥")
			continue
		}
		
		if result.Success {
			successCount++
			zlog.Info().
				Str("device", point.DeviceID).
				Interface("data", result.Data).
				Msg("èšåˆå¤„ç†æˆåŠŸ")
		}
	}
	
	// è·å–ç»Ÿè®¡ä¿¡æ¯
	stats := manager.GetStats()
	
	duration := time.Since(start)
	success := successCount > 0 && successCount <= totalProcessed
	
	ts.AddResult(TestResult{
		TestName: "èšåˆç®¡ç†å™¨åŠŸèƒ½æµ‹è¯•",
		Success:  success,
		Duration: duration,
		Message:  fmt.Sprintf("æˆåŠŸå¤„ç† %d/%d æ•°æ®ç‚¹", successCount, totalProcessed),
		Metrics:  stats,
	})
}

// testRuleExecution æµ‹è¯•è§„åˆ™æ‰§è¡Œ
func testRuleExecution(ts *TestSuite) {
	fmt.Println("âš™ï¸ æµ‹è¯•è§„åˆ™æ‰§è¡Œ...")
	
	start := time.Now()
	
	// æ¨¡æ‹Ÿè§„åˆ™æ‰§è¡Œæµ‹è¯•
	// æ³¨ï¼šè¿™é‡Œéœ€è¦å®é™…çš„è§„åˆ™ç®¡ç†å™¨å®ä¾‹ï¼Œç®€åŒ–ä¸ºåŸºæœ¬éªŒè¯
	
	testRule := &rules.Rule{
		ID:       "test_execution_rule",
		Name:     "æµ‹è¯•æ‰§è¡Œè§„åˆ™",
		Enabled:  true,
		Priority: 100,
		Conditions: &rules.Condition{
			Type:     "expression",
			Expression: "value > 25",
		},
		Actions: []rules.Action{
			{
				Type: "transform",
				Config: map[string]interface{}{
					"type": "scale",
					"factor": 1.8,
					"offset": 32,
				},
			},
		},
	}
	
	// åˆ›å»ºæµ‹è¯•æ•°æ®ç‚¹
	testPoint := model.Point{
		DeviceID:  "test_device",
		Key:       "temperature",
		Value:     30.0,
		Timestamp: time.Now(),
		Type:      "float",
	}
	
	// åŸºæœ¬éªŒè¯
	success := testRule.ID != "" && testRule.Enabled && len(testRule.Actions) > 0
	message := "è§„åˆ™ç»“æ„éªŒè¯é€šè¿‡"
	
	if !success {
		message = "è§„åˆ™ç»“æ„éªŒè¯å¤±è´¥"
	}
	
	duration := time.Since(start)
	
	ts.AddResult(TestResult{
		TestName: "è§„åˆ™æ‰§è¡Œæµç¨‹æµ‹è¯•",
		Success:  success,
		Duration: duration,
		Message:  message,
		Metrics: map[string]interface{}{
			"rule_id":      testRule.ID,
			"actions_count": len(testRule.Actions),
			"data_point":   testPoint,
		},
	})
}

// testMonitoringSystem æµ‹è¯•ç›‘æ§ç³»ç»Ÿ
func testMonitoringSystem(ts *TestSuite) {
	fmt.Println("ğŸ“ˆ æµ‹è¯•ç›‘æ§ç³»ç»Ÿ...")
	
	start := time.Now()
	
	// åˆ›å»ºç›‘æ§å®ä¾‹
	monitor := rules.NewRuleMonitor()
	
	// è®°å½•ä¸€äº›æµ‹è¯•æŒ‡æ ‡
	monitor.RecordRuleExecution("test_rule", time.Millisecond*50, true)
	monitor.RecordRuleExecution("test_rule", time.Millisecond*75, true) 
	monitor.RecordRuleExecution("test_rule", time.Millisecond*30, false)
	
	monitor.RecordError("test_rule", "validation", "warning", "æµ‹è¯•è­¦å‘Š", map[string]interface{}{
		"test": true,
	})
	
	// è·å–ç»Ÿè®¡ä¿¡æ¯
	stats := monitor.GetStats()
	health := monitor.HealthCheck()
	
	// éªŒè¯ç›‘æ§æ•°æ®
	success := true
	var errors []string
	
	if stats["total_executions"] != 3 {
		success = false
		errors = append(errors, fmt.Sprintf("æ‰§è¡Œæ¬¡æ•°é”™è¯¯: æœŸæœ›3, å®é™…%v", stats["total_executions"]))
	}
	
	if stats["success_count"] != 2 {
		success = false
		errors = append(errors, fmt.Sprintf("æˆåŠŸæ¬¡æ•°é”™è¯¯: æœŸæœ›2, å®é™…%v", stats["success_count"]))
	}
	
	if health["status"] != "healthy" {
		success = false
		errors = append(errors, fmt.Sprintf("å¥åº·çŠ¶æ€é”™è¯¯: æœŸæœ›healthy, å®é™…%v", health["status"]))
	}
	
	duration := time.Since(start)
	errorMsg := ""
	if len(errors) > 0 {
		errorMsg = fmt.Sprintf("éªŒè¯å¤±è´¥: %v", errors)
	}
	
	ts.AddResult(TestResult{
		TestName: "ç›‘æ§ç³»ç»ŸåŠŸèƒ½æµ‹è¯•",
		Success:  success,
		Duration: duration,
		Message:  "éªŒè¯ç›‘æ§æŒ‡æ ‡è®°å½•å’Œå¥åº·æ£€æŸ¥",
		Error:    errorMsg,
		Metrics: map[string]interface{}{
			"stats":  stats,
			"health": health,
		},
	})
}

// testPerformanceBenchmark æ€§èƒ½åŸºå‡†æµ‹è¯•
func testPerformanceBenchmark(ts *TestSuite) {
	fmt.Println("ğŸƒâ€â™‚ï¸ æ‰§è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•...")
	
	start := time.Now()
	
	// è¡¨è¾¾å¼æ€§èƒ½æµ‹è¯•
	engine := rules.NewExpressionEngine()
	
	// æµ‹è¯•è¡¨è¾¾å¼ç¼–è¯‘æ€§èƒ½
	expressions := []string{
		"value > 30",
		"value > 20 && value < 100",
		"sqrt(value) > 5 && contains(device_id, 'sensor')",
		"abs(value - avg_value) > 2 * stddev_value",
	}
	
	compilationTimes := make([]time.Duration, len(expressions))
	evaluationTimes := make([]time.Duration, len(expressions))
	
	for i, expr := range expressions {
		// æµ‹è¯•ç¼–è¯‘æ—¶é—´
		compileStart := time.Now()
		_, err := engine.Evaluate(expr, map[string]interface{}{
			"value": 35.0,
			"device_id": "sensor_001",
			"avg_value": 30.0,
			"stddev_value": 5.0,
		})
		compilationTimes[i] = time.Since(compileStart)
		
		if err != nil {
			zlog.Error().Err(err).Str("expression", expr).Msg("è¡¨è¾¾å¼è¯„ä¼°å¤±è´¥")
			continue
		}
		
		// æµ‹è¯•è¯„ä¼°æ€§èƒ½ï¼ˆå¤šæ¬¡è¯„ä¼°ï¼‰
		evalStart := time.Now()
		for j := 0; j < 1000; j++ {
			engine.Evaluate(expr, map[string]interface{}{
				"value": float64(20 + j%60),
				"device_id": "sensor_001",
				"avg_value": 30.0,
				"stddev_value": 5.0,
			})
		}
		evaluationTimes[i] = time.Since(evalStart)
	}
	
	// å¢é‡ç»Ÿè®¡æ€§èƒ½æµ‹è¯•
	stats := rules.NewIncrementalStats(false)
	statsStart := time.Now()
	for i := 0; i < 10000; i++ {
		stats.AddValue(float64(rand.Intn(100)))
	}
	statsResults := stats.GetResults()
	statsDuration := time.Since(statsStart)
	
	duration := time.Since(start)
	
	// è®¡ç®—å¹³å‡æ€§èƒ½
	avgCompilation := time.Duration(0)
	avgEvaluation := time.Duration(0)
	for i := range expressions {
		avgCompilation += compilationTimes[i]
		avgEvaluation += evaluationTimes[i]
	}
	avgCompilation /= time.Duration(len(expressions))
	avgEvaluation /= time.Duration(len(expressions))
	
	// æ€§èƒ½è¦æ±‚éªŒè¯
	success := true
	var perfIssues []string
	
	if avgCompilation > time.Millisecond*10 {
		success = false
		perfIssues = append(perfIssues, fmt.Sprintf("è¡¨è¾¾å¼ç¼–è¯‘è¿‡æ…¢: %v", avgCompilation))
	}
	
	if avgEvaluation > time.Millisecond*100 {
		success = false
		perfIssues = append(perfIssues, fmt.Sprintf("è¡¨è¾¾å¼è¯„ä¼°è¿‡æ…¢: %v", avgEvaluation))
	}
	
	if statsDuration > time.Millisecond*500 {
		success = false
		perfIssues = append(perfIssues, fmt.Sprintf("ç»Ÿè®¡è®¡ç®—è¿‡æ…¢: %v", statsDuration))
	}
	
	message := "æ€§èƒ½æŒ‡æ ‡ç¬¦åˆè¦æ±‚"
	if len(perfIssues) > 0 {
		message = fmt.Sprintf("å‘ç°æ€§èƒ½é—®é¢˜: %v", perfIssues)
	}
	
	ts.AddResult(TestResult{
		TestName: "æ€§èƒ½åŸºå‡†æµ‹è¯•",
		Success:  success,
		Duration: duration,
		Message:  message,
		Metrics: map[string]interface{}{
			"avg_compilation_time": avgCompilation,
			"avg_evaluation_time":  avgEvaluation,
			"stats_duration":       statsDuration,
			"stats_operations":     10000,
			"stats_results":        statsResults,
		},
	})
}

// testConcurrencyStress å¹¶å‘å‹åŠ›æµ‹è¯•
func testConcurrencyStress(ts *TestSuite) {
	fmt.Println("ğŸ”„ æ‰§è¡Œå¹¶å‘å‹åŠ›æµ‹è¯•...")
	
	start := time.Now()
	
	// åˆ›å»ºå¹¶å‘æµ‹è¯•ç¯å¢ƒ
	engine := rules.NewExpressionEngine()
	stats := rules.NewIncrementalStats(false)
	
	// å¹¶å‘å‚æ•°
	numGoroutines := 50
	operationsPerGoroutine := 1000
	
	var wg sync.WaitGroup
	var mu sync.Mutex
	successCount := 0
	errorCount := 0
	
	// å¯åŠ¨å¹¶å‘è¡¨è¾¾å¼è¯„ä¼°
	for i := 0; i < numGoroutines; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			
			localSuccess := 0
			localErrors := 0
			
			for j := 0; j < operationsPerGoroutine; j++ {
				// éšæœºè¡¨è¾¾å¼è¯„ä¼°
				expressions := []string{
					"value > 30",
					"value > 20 && value < 80",
					"sqrt(value) > 3",
				}
				
				expr := expressions[j%len(expressions)]
				data := map[string]interface{}{
					"value": float64(rand.Intn(100)),
				}
				
				_, err := engine.Evaluate(expr, data)
				if err != nil {
					localErrors++
				} else {
					localSuccess++
				}
				
				// å¹¶å‘ç»Ÿè®¡æ›´æ–°
				stats.AddValue(float64(rand.Intn(100)))
			}
			
			mu.Lock()
			successCount += localSuccess
			errorCount += localErrors
			mu.Unlock()
		}(i)
	}
	
	// ç­‰å¾…æ‰€æœ‰goroutineå®Œæˆ
	wg.Wait()
	
	duration := time.Since(start)
	totalOperations := numGoroutines * operationsPerGoroutine
	
	// éªŒè¯å¹¶å‘å®‰å…¨æ€§
	success := true
	var issues []string
	
	if errorCount > totalOperations/100 { // é”™è¯¯ç‡è¶…è¿‡1%
		success = false
		issues = append(issues, fmt.Sprintf("é”™è¯¯ç‡è¿‡é«˜: %d/%d", errorCount, totalOperations))
	}
	
	statsResults := stats.GetResults()
	if statsResults["count"].(int) != numGoroutines*operationsPerGoroutine {
		success = false
		issues = append(issues, fmt.Sprintf("ç»Ÿè®¡è®¡æ•°é”™è¯¯: æœŸæœ›%d, å®é™…%d", 
			numGoroutines*operationsPerGoroutine, statsResults["count"]))
	}
	
	message := fmt.Sprintf("å¹¶å‘æ‰§è¡Œ %d ä¸ªæ“ä½œ", totalOperations)
	if len(issues) > 0 {
		message = fmt.Sprintf("å‘ç°å¹¶å‘é—®é¢˜: %v", issues)
	}
	
	ts.AddResult(TestResult{
		TestName: "å¹¶å‘å‹åŠ›æµ‹è¯•",
		Success:  success,
		Duration: duration,
		Message:  message,
		Metrics: map[string]interface{}{
			"total_operations":  totalOperations,
			"success_count":     successCount,
			"error_count":       errorCount,
			"goroutines":        numGoroutines,
			"ops_per_goroutine": operationsPerGoroutine,
			"ops_per_second":    float64(totalOperations) / duration.Seconds(),
			"stats_results":     statsResults,
		},
	})
}

func main() {
	runRuleEngineTests()
}