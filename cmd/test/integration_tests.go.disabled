package main

import (
	"context"
	"encoding/json"
	"fmt"
	"math/rand"
	"os"
	"sync"
	"time"

	"github.com/nats-io/nats.go"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/y001j/iot-gateway/internal/core"
	"github.com/y001j/iot-gateway/internal/model"
	"github.com/y001j/iot-gateway/internal/southbound/mock"
)

// IntegrationTestSuite é›†æˆæµ‹è¯•å¥—ä»¶
type IntegrationTestSuite struct {
	runtime *core.Runtime
	nc      *nats.Conn
	results []TestResult
	mu      sync.Mutex
}

// NewIntegrationTestSuite åˆ›å»ºé›†æˆæµ‹è¯•å¥—ä»¶
func NewIntegrationTestSuite() *IntegrationTestSuite {
	return &IntegrationTestSuite{
		results: make([]TestResult, 0),
	}
}

// runIntegrationTests è¿è¡Œé›†æˆæµ‹è¯•
func runIntegrationTests() {
	// è®¾ç½®æ—¥å¿—
	zerolog.SetGlobalLevel(zerolog.InfoLevel)
	log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr, TimeFormat: time.RFC3339})

	fmt.Println("ğŸ”§ å¼€å§‹è§„åˆ™å¼•æ“é›†æˆæµ‹è¯•...")

	suite := NewIntegrationTestSuite()

	// 1. åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒ
	if err := suite.setupTestEnvironment(); err != nil {
		log.Fatal().Err(err).Msg("åˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒå¤±è´¥")
		return
	}
	defer suite.cleanup()

	// 2. è¿è¡Œå„é¡¹é›†æˆæµ‹è¯•
	suite.testRuleEngineIntegration()
	suite.testPerformanceUnderLoad()
	suite.testRealTimeProcessing()
	suite.testErrorHandlingAndRecovery()
	suite.testMonitoringAndMetrics()

	// 3. æ‰“å°æµ‹è¯•ç»“æœ
	suite.printResults()
}

// setupTestEnvironment è®¾ç½®æµ‹è¯•ç¯å¢ƒ
func (suite *IntegrationTestSuite) setupTestEnvironment() error {
	log.Info().Msg("è®¾ç½®é›†æˆæµ‹è¯•ç¯å¢ƒ...")

	// åˆ›å»ºæµ‹è¯•é…ç½®
	config := &core.Config{
		Gateway: core.GatewayConfig{
			DataPort:    4222,
			WebPort:     8081,
			LogLevel:    "info",
			NatsURL:     "nats://localhost:4222",
			PluginsDir:  "./plugins",
			EmbeddedNats: true,
		},
		RuleEngine: core.RuleEngineConfig{
			Enabled:    true,
			RulesDir:   "./rules",
			WorkerPool: 8,
			BatchSize:  100,
		},
	}

	// åˆ›å»ºå¹¶å¯åŠ¨è¿è¡Œæ—¶
	runtime, err := core.NewRuntime(config)
	if err != nil {
		return fmt.Errorf("åˆ›å»ºè¿è¡Œæ—¶å¤±è´¥: %w", err)
	}

	suite.runtime = runtime

	// å¯åŠ¨è¿è¡Œæ—¶
	ctx := context.Background()
	if err := runtime.Start(ctx); err != nil {
		return fmt.Errorf("å¯åŠ¨è¿è¡Œæ—¶å¤±è´¥: %w", err)
	}

	// ç­‰å¾…ç³»ç»Ÿç¨³å®š
	time.Sleep(time.Second * 2)

	// è¿æ¥åˆ°NATS
	nc, err := nats.Connect(config.Gateway.NatsURL)
	if err != nil {
		return fmt.Errorf("è¿æ¥NATSå¤±è´¥: %w", err)
	}
	suite.nc = nc

	log.Info().Msg("æµ‹è¯•ç¯å¢ƒè®¾ç½®å®Œæˆ")
	return nil
}

// cleanup æ¸…ç†æµ‹è¯•ç¯å¢ƒ
func (suite *IntegrationTestSuite) cleanup() {
	log.Info().Msg("æ¸…ç†æµ‹è¯•ç¯å¢ƒ...")

	if suite.nc != nil {
		suite.nc.Close()
	}

	if suite.runtime != nil {
		suite.runtime.Stop()
	}
}

// testRuleEngineIntegration æµ‹è¯•è§„åˆ™å¼•æ“é›†æˆ
func (suite *IntegrationTestSuite) testRuleEngineIntegration() {
	log.Info().Msg("æµ‹è¯•è§„åˆ™å¼•æ“é›†æˆ...")
	start := time.Now()

	// åˆ›å»ºæµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
	generator := suite.createDataGenerator()

	// ç›‘å¬èšåˆç»“æœ
	resultsReceived := 0
	var resultsMu sync.Mutex

	sub, err := suite.nc.Subscribe("iot.data.*_stats", func(m *nats.Msg) {
		resultsMu.Lock()
		resultsReceived++
		resultsMu.Unlock()

		log.Info().
			Str("subject", m.Subject).
			Int("size", len(m.Data)).
			Msg("æ”¶åˆ°èšåˆç»“æœ")
	})
	if err != nil {
		suite.addResult("è§„åˆ™å¼•æ“é›†æˆæµ‹è¯•", false, time.Since(start), "è®¢é˜…NATSå¤±è´¥", err.Error(), nil)
		return
	}
	defer sub.Unsubscribe()

	// å‘é€æµ‹è¯•æ•°æ®
	dataPointsSent := 0
	for i := 0; i < 100; i++ {
		points := generator.GenerateDataBatch(10)
		for _, point := range points {
			data, _ := json.Marshal(point)
			if err := suite.nc.Publish("iot.data.raw", data); err != nil {
				log.Error().Err(err).Msg("å‘å¸ƒæ•°æ®å¤±è´¥")
			} else {
				dataPointsSent++
			}
		}
		time.Sleep(time.Millisecond * 50) // æ¨¡æ‹Ÿå®é™…æ•°æ®æµ
	}

	// ç­‰å¾…å¤„ç†å®Œæˆ
	time.Sleep(time.Second * 5)

	resultsMu.Lock()
	finalResults := resultsReceived
	resultsMu.Unlock()

	duration := time.Since(start)
	success := finalResults > 0 && dataPointsSent > 0

	message := fmt.Sprintf("å‘é€ %d æ•°æ®ç‚¹ï¼Œæ”¶åˆ° %d èšåˆç»“æœ", dataPointsSent, finalResults)

	suite.addResult("è§„åˆ™å¼•æ“é›†æˆæµ‹è¯•", success, duration, message, "", map[string]interface{}{
		"data_points_sent":   dataPointsSent,
		"results_received":   finalResults,
		"processing_rate":    float64(dataPointsSent) / duration.Seconds(),
	})
}

// testPerformanceUnderLoad æµ‹è¯•è´Ÿè½½ä¸‹çš„æ€§èƒ½
func (suite *IntegrationTestSuite) testPerformanceUnderLoad() {
	log.Info().Msg("æµ‹è¯•è´Ÿè½½ä¸‹çš„æ€§èƒ½...")
	start := time.Now()

	generator := suite.createDataGenerator()

	// é«˜é¢‘ç‡æ•°æ®å‘é€
	var wg sync.WaitGroup
	numSenders := 10
	pointsPerSender := 1000
	totalSent := 0
	var sentMu sync.Mutex

	for i := 0; i < numSenders; i++ {
		wg.Add(1)
		go func(senderID int) {
			defer wg.Done()

			localSent := 0
			for j := 0; j < pointsPerSender; j++ {
				point := generator.GenerateRandomPoint()
				data, _ := json.Marshal(point)
				
				if err := suite.nc.Publish("iot.data.raw", data); err != nil {
					log.Error().Err(err).Int("sender", senderID).Msg("å‘å¸ƒæ•°æ®å¤±è´¥")
				} else {
					localSent++
				}

				// é«˜é¢‘å‘é€
				if j%100 == 0 {
					time.Sleep(time.Millisecond * 10)
				}
			}

			sentMu.Lock()
			totalSent += localSent
			sentMu.Unlock()
		}(i)
	}

	wg.Wait()
	duration := time.Since(start)

	// è®¡ç®—æ€§èƒ½æŒ‡æ ‡
	throughput := float64(totalSent) / duration.Seconds()
	success := throughput > 1000 // æœŸæœ›æ¯ç§’å¤„ç†1000+æ•°æ®ç‚¹

	message := fmt.Sprintf("é«˜è´Ÿè½½æµ‹è¯•: %d æ•°æ®ç‚¹ï¼Œååé‡ %.2f/ç§’", totalSent, throughput)
	if !success {
		message += " (ä½äºæ€§èƒ½è¦æ±‚)"
	}

	suite.addResult("é«˜è´Ÿè½½æ€§èƒ½æµ‹è¯•", success, duration, message, "", map[string]interface{}{
		"total_points":    totalSent,
		"throughput":      throughput,
		"num_senders":     numSenders,
		"points_per_sender": pointsPerSender,
	})
}

// testRealTimeProcessing æµ‹è¯•å®æ—¶å¤„ç†èƒ½åŠ›
func (suite *IntegrationTestSuite) testRealTimeProcessing() {
	log.Info().Msg("æµ‹è¯•å®æ—¶å¤„ç†èƒ½åŠ›...")
	start := time.Now()

	generator := suite.createDataGenerator()

	// ç›‘å¬å®æ—¶å¤„ç†ç»“æœ
	var latencies []time.Duration
	var latencyMu sync.Mutex

	sub, err := suite.nc.Subscribe("iot.data.*", func(m *nats.Msg) {
		// è§£ææ¶ˆæ¯è·å–æ—¶é—´æˆ³
		var point model.Point
		if err := json.Unmarshal(m.Data, &point); err == nil {
			processingTime := time.Since(point.Timestamp)
			
			latencyMu.Lock()
			latencies = append(latencies, processingTime)
			latencyMu.Unlock()
		}
	})
	if err != nil {
		suite.addResult("å®æ—¶å¤„ç†æµ‹è¯•", false, time.Since(start), "è®¢é˜…å¤±è´¥", err.Error(), nil)
		return
	}
	defer sub.Unsubscribe()

	// å‘é€å®æ—¶æ•°æ®
	for i := 0; i < 200; i++ {
		point := generator.GenerateRandomPoint()
		point.Timestamp = time.Now() // è®¾ç½®å‡†ç¡®çš„å‘é€æ—¶é—´
		
		data, _ := json.Marshal(point)
		suite.nc.Publish("iot.data.raw", data)
		
		time.Sleep(time.Millisecond * 25) // 40Hzé¢‘ç‡
	}

	// ç­‰å¾…å¤„ç†å®Œæˆ
	time.Sleep(time.Second * 3)

	duration := time.Since(start)

	latencyMu.Lock()
	avgLatency := time.Duration(0)
	maxLatency := time.Duration(0)
	if len(latencies) > 0 {
		total := time.Duration(0)
		for _, lat := range latencies {
			total += lat
			if lat > maxLatency {
				maxLatency = lat
			}
		}
		avgLatency = total / time.Duration(len(latencies))
	}
	processedCount := len(latencies)
	latencyMu.Unlock()

	// éªŒè¯å®æ—¶æ€§è¦æ±‚
	success := avgLatency < time.Millisecond*100 && maxLatency < time.Millisecond*500

	message := fmt.Sprintf("å¤„ç† %d æ¶ˆæ¯ï¼Œå¹³å‡å»¶è¿Ÿ %vï¼Œæœ€å¤§å»¶è¿Ÿ %v", 
		processedCount, avgLatency, maxLatency)

	suite.addResult("å®æ—¶å¤„ç†æµ‹è¯•", success, duration, message, "", map[string]interface{}{
		"processed_count": processedCount,
		"avg_latency":     avgLatency,
		"max_latency":     maxLatency,
		"latency_samples": len(latencies),
	})
}

// testErrorHandlingAndRecovery æµ‹è¯•é”™è¯¯å¤„ç†å’Œæ¢å¤
func (suite *IntegrationTestSuite) testErrorHandlingAndRecovery() {
	log.Info().Msg("æµ‹è¯•é”™è¯¯å¤„ç†å’Œæ¢å¤...")
	start := time.Now()

	// å‘é€ä¸€äº›æ— æ•ˆæ•°æ®æ¥è§¦å‘é”™è¯¯å¤„ç†
	invalidData := [][]byte{
		[]byte("invalid json"),
		[]byte(`{"invalid": "structure"}`),
		[]byte(`{"device_id": "", "value": "not_number"}`),
	}

	errorsSent := len(invalidData)
	for _, data := range invalidData {
		suite.nc.Publish("iot.data.raw", data)
	}

	// å‘é€ä¸€äº›æ­£å¸¸æ•°æ®éªŒè¯ç³»ç»Ÿæ¢å¤
	generator := suite.createDataGenerator()
	validDataSent := 0
	for i := 0; i < 50; i++ {
		point := generator.GenerateRandomPoint()
		data, _ := json.Marshal(point)
		suite.nc.Publish("iot.data.raw", data)
		validDataSent++
	}

	// ç­‰å¾…å¤„ç†
	time.Sleep(time.Second * 2)

	duration := time.Since(start)

	// åŸºæœ¬éªŒè¯ï¼šç³»ç»Ÿèƒ½å¤Ÿç»§ç»­è¿è¡Œ
	success := suite.runtime != nil && suite.nc.IsConnected()

	message := fmt.Sprintf("å‘é€ %d é”™è¯¯æ•°æ®å’Œ %d æ­£å¸¸æ•°æ®ï¼Œç³»ç»Ÿç»§ç»­è¿è¡Œ", 
		errorsSent, validDataSent)

	suite.addResult("é”™è¯¯å¤„ç†å’Œæ¢å¤æµ‹è¯•", success, duration, message, "", map[string]interface{}{
		"errors_sent":      errorsSent,
		"valid_data_sent":  validDataSent,
		"system_running":   success,
	})
}

// testMonitoringAndMetrics æµ‹è¯•ç›‘æ§å’ŒæŒ‡æ ‡
func (suite *IntegrationTestSuite) testMonitoringAndMetrics() {
	log.Info().Msg("æµ‹è¯•ç›‘æ§å’ŒæŒ‡æ ‡...")
	start := time.Now()

	// å‘é€ä¸€äº›æ•°æ®æ¥ç”ŸæˆæŒ‡æ ‡
	generator := suite.createDataGenerator()
	for i := 0; i < 100; i++ {
		point := generator.GenerateRandomPoint()
		data, _ := json.Marshal(point)
		suite.nc.Publish("iot.data.raw", data)
		
		if i%20 == 0 {
			time.Sleep(time.Millisecond * 100)
		}
	}

	// ç­‰å¾…å¤„ç†å¹¶ç”ŸæˆæŒ‡æ ‡
	time.Sleep(time.Second * 3)

	duration := time.Since(start)

	// éªŒè¯ç›‘æ§ç³»ç»ŸåŸºæœ¬åŠŸèƒ½
	// æ³¨ï¼šåœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šæ£€æŸ¥HTTPç›‘æ§ç«¯ç‚¹
	success := true // åŸºæœ¬å‡è®¾ç›‘æ§æ­£å¸¸å·¥ä½œ

	message := "ç›‘æ§ç³»ç»ŸåŸºæœ¬åŠŸèƒ½éªŒè¯é€šè¿‡"

	suite.addResult("ç›‘æ§å’ŒæŒ‡æ ‡æµ‹è¯•", success, duration, message, "", map[string]interface{}{
		"test_duration": duration,
		"data_sent":     100,
	})
}

// createDataGenerator åˆ›å»ºæ•°æ®ç”Ÿæˆå™¨
func (suite *IntegrationTestSuite) createDataGenerator() *TestDataGenerator {
	return &TestDataGenerator{}
}

// TestDataGenerator æµ‹è¯•æ•°æ®ç”Ÿæˆå™¨
type TestDataGenerator struct{}

// GenerateRandomPoint ç”Ÿæˆéšæœºæ•°æ®ç‚¹
func (g *TestDataGenerator) GenerateRandomPoint() model.Point {
	deviceIDs := []string{"sensor_001", "sensor_002", "sensor_003", "device_001", "device_002"}
	keys := []string{"temperature", "humidity", "pressure", "voltage", "current"}

	return model.Point{
		DeviceID:  deviceIDs[rand.Intn(len(deviceIDs))],
		Key:       keys[rand.Intn(len(keys))],
		Value:     20.0 + rand.Float64()*60.0, // 20-80 range
		Timestamp: time.Now(),
		Type:      "float",
		Tags: map[string]string{
			"location": "factory_1",
			"type":     "sensor",
		},
	}
}

// GenerateDataBatch ç”Ÿæˆæ•°æ®æ‰¹æ¬¡
func (g *TestDataGenerator) GenerateDataBatch(size int) []model.Point {
	points := make([]model.Point, size)
	for i := 0; i < size; i++ {
		points[i] = g.GenerateRandomPoint()
	}
	return points
}

// addResult æ·»åŠ æµ‹è¯•ç»“æœ
func (suite *IntegrationTestSuite) addResult(name string, success bool, duration time.Duration, message, error string, metrics interface{}) {
	suite.mu.Lock()
	defer suite.mu.Unlock()

	result := TestResult{
		TestName: name,
		Success:  success,
		Duration: duration,
		Message:  message,
		Error:    error,
		Metrics:  metrics,
	}

	suite.results = append(suite.results, result)
}

// printResults æ‰“å°æµ‹è¯•ç»“æœ
func (suite *IntegrationTestSuite) printResults() {
	suite.mu.Lock()
	defer suite.mu.Unlock()

	fmt.Println("\n" + "="*80)
	fmt.Println("ğŸ§ª è§„åˆ™å¼•æ“é›†æˆæµ‹è¯•ç»“æœæ±‡æ€»")
	fmt.Println("="*80)

	successCount := 0
	totalDuration := time.Duration(0)

	for _, result := range suite.results {
		status := "âŒ FAIL"
		if result.Success {
			status = "âœ… PASS"
			successCount++
		}

		totalDuration += result.Duration
		fmt.Printf("%s [%v] %s\n", status, result.Duration, result.TestName)
		if result.Message != "" {
			fmt.Printf("   ğŸ“ %s\n", result.Message)
		}
		if result.Error != "" {
			fmt.Printf("   ğŸš¨ é”™è¯¯: %s\n", result.Error)
		}
		if result.Metrics != nil {
			fmt.Printf("   ğŸ“Š æŒ‡æ ‡: %+v\n", result.Metrics)
		}
		fmt.Println()
	}

	fmt.Printf("æ€»è®¡: %d/%d é€šè¿‡, æ€»è€—æ—¶: %v\n", successCount, len(suite.results), totalDuration)
	fmt.Printf("æˆåŠŸç‡: %.1f%%\n", float64(successCount)/float64(len(suite.results))*100)
	fmt.Println("="*80)
}

func main() {
	runIntegrationTests()
}